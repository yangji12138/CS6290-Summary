\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{tikzscale}
\usetikzlibrary{backgrounds,calc,decorations.pathreplacing,fit,matrix,patterns,positioning,shapes,shapes.multipart}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{An Investigation into Stateless Blockchain}

\author{
\IEEEauthorblockN{Yang Ji}
\IEEEauthorblockA{Dept. of Computer Science \\
ID: 56064832}
}

\maketitle


\section{Introduction}
Recent years have witnessed the prosperity of cryptocurrencies which seek for more efficient and secure financial
transactions through removing trusted third parties like escrows and banks~\cite{SongWP00}.
%
As their underlying technology, blockchain enables users to broadcast and confirm asynchronous transactions securely in an untrusted environment.
%
In order to achieve this, nodes in blockchain systems need to validate broadcasted transactions by querying the current system \textit{state}.
%
To be more specific, this state can be available by storing subsequent ordered blocks from the genesis block in local.

However, due to the ever-growing nature of the blockchain systems, the storage requirement is increasing linearly with the ledger length.
%
This restricted condition entails taking much storage space and time to download and maintain the entire history of blockchains.
%
For example, a new full node that wants to join in the Ethereum network and acquires the correct ledger \textit{state} needs to download 132.57 GB of data~\cite{Ethereumstorage} currently. 

As the emerging concerns on chain data size in the developer community, the concept of `stateless' blockchain has received considerable interests nowadays.
%
This concept is derived from a personal blog~\cite{delayed-txo-commitments}, which is proposed to avoid storing the whole state in an accumulative manner.
%
Unfortunately, realizing a blockchain system with lessened storage requirement is a quite difficult task due to many challenges.

For one thing, maintaining a public ledger in a decentralized system entails the duties of validating and broadcasting transaction on each node.
%
In order to check the validation of each transaction, nodes must store the current ledger \textit{state} that determines the ownership of existing assets.
%
For instance, the \textit{state} of Bitcoin is a data set of unspent transaction outputs (UTXOs). 
%
In order to check the validation of transactions, nodes should confirm that spent coin belongs to UTXO set locally.
%
In other words, nodes without storing UTXO set can't validate the incoming transactions.

For another thing, sharding or commitment schemes are viewed as effective methods to reduce the storage cost on each node.
%
In these ways, nodes could verify transactions by checking the membership proofs provided by issuers.
%
However, these solutions are actually at the cost of communication overhead across the system.
%
And high communication overhead would inevitably lead to the low scalability and throughput of the entire network, which is against the principles of cryptocurrencies.
%
How to leverage these tools to realize a cryptocurrency protocol is a challenging open question in blockchain community.

With these unresolved problems, I conduct an investigation into state-of-the-art solutions of stateless blockchain in this paper.
%
By categorizing existing literatures, I
%
I then pick up some important literatures and explain their algorithms in more detail.
%
By providing comprehensive evaluations for these methods, 

The rest of this paper is organized as follows: 


\begin{figure}[t]
  \centering
  \resizebox{0.7\linewidth}{!}{\input{figs/model.tex}}
  \caption{System Architecture}\label{fig:model}
\end{figure}

\section{Application Setting}
\subsection{System Architecture}
In this subsection, I will briefly introduce the system architecture of current blockchains.
%
As shown in Figure, there exist three kinds of nodes with different functionalities in a classical blockchain network:
\textit{full nodes}, \textit{miners} and \textit{light nodes}.
%
To fulfill the security model, full nodes must download blocks originated from the first block all the way and validate them against consensus proof.
%
To be specific, a full node store all blocks including block headers and data records on the disk.
%
Miners are full nodes with high computational power, who could execute consensus protocol (e.g. hash puzzle in Bitcoin) and generate new blocks for money rewards.
%
Restricted in limited resources, a light node only needs to download block headers during the initial syncing process and then requests transactions from connected full nodes as needed.

\subsection{Stateless Blockchain}
In the current blockchain system, locally maintaining the validation state means quite cumbersome work. 
%
On one hand, this high storage requirement potentially fails those users who can't dedicate large storage space to join in the network.
%
More than that, increasing storage requirement might also reduce the incentives for running full nodes, which could lead to possible centralization of blockchains.
%
On the other hand, full nodes tend to leverage database (e.g. LevelDB in geth client) to manage the entire ledger \textit{state},
which causes expensive I/O costs and prolong the validation time.

Due to the above concerns, the blockchain community is eager for a well-designed protocol to tackle these issues by lessening or even removing local validation state.

%\begin{table}[h]
%\centering
%\caption{Comparison of encrypted search schemes.}
%\label{my-label}
%\begin{tabular}{|l|l|l|}
%\hline
%Scheme & Search Complexity & Index Size \\ \hline
%\cite{SongWP00}   & ...              & ...       \\ \hline
%...    & ...               & ...        \\ \hline
%\end{tabular}
%\end{table}



\section{Background on transaction validation in current blockchain systems}
In this part, I will take Ethereum as an example to untangle the intricacies in the data storage layer that exists in full nodes.
%
In Ethereum, developers have implemented many optimizations on the original data structure called Merkle Patricia Tries.
%
These data in local databases and on-chain block headers jointly contribute to the `World State' in blockchains.
%
What's more, the concept of `stateless' blockchain can be also applied into lightweight node. 
%
I will explain the details later.

\begin{figure}[!t]
  \centering
  \includegraphics[width=2in]{figs/Trie.png}
  \caption{Trie Data Structure}
  \label{trie}
\end{figure}

\subsection{Data Storage in Full Node}
The core data structures which exist in Ethereum are made up of optimized Merkle Patricia Tries.
%
The term trie is derived from the word `Re{\textbf{tri}}eve' and the same as tree. 
%
Trie data structure, which is also called digital tree, radix tree and prefix tree, could be used to store the dynamic maps of key-value.  
%
We can efficiently traverse a branch of nodes in the trie with the reference to the corresponding keys.
%
For example, in Figure~\ref{trie}, the sequence of English alphabet is used to comprise the key. 
%
In the path of retrieving the value, the same sequences are grouped together to avoid massive of wasted space.

Many optimized implementations have been applied into the Ethereum's trie data structure in order to increase the search efficiency and performance.
%
In the Ethereum's official document, Merkle Patricia trie are defined as a cryptographically authenticated data structure that is used to store all bindings of key and value.
%
The hash function of each node, as I have mentioned in my first assignment before, could guarantee the data integrity and provide fast verification for users.
%
As for query processing, this unique data structure enables inserting, searching and deleting operations in the complexity of O(log(n)).
%
In engineering, some encoding schemes like Hex-Prefix encoding and Recursive Length Prefix (RLP) are also used for improving the query performance.
%
To conclude that, tries are enforced with cryptographic security by leveraging the hash function to reference each node.
%
And these tries could provide the efficient inserting, searching and deleting operations in local databases (Leveldb or Rocksdb).

\begin{figure}[!t]
  \centering
  \includegraphics[width=\linewidth]{figs/Ethereum-tree.png}
  \caption{Ethereum Storage Layer}
  \label{e-trie}
\end{figure}

In order to maintain the state of the whole blockchain, Ethereum blocks contain four distinct trie data structures: (1)\textit{Receipt Tree} (2)\textit{State Tree} (3)\textit{Transaction Tree} (4)\textit{Storage Tree}.
%
As illustrated in Figure~\ref{e-trie}, The hash roots of first three merkle patricia tries are stored in the block headers in the form of Keccak 256-bit hash value. 
%
The hash root of \textit{Storage Tree} is included in \textit{State Tree} with its RLP encoded data records.

In more detail, \textit{Transaction Trie} is proposed to record transactions in the current block.
%
Thus, once the block is appended into the main chain, \textit{Transaction Trie} is also fixed and never updated.
%
Same as \textit{Transaction tree}, \textit{Receipt Tree} is used to record the outcome of transactions and never updated.
%
In Ethereum yellow paper\cite{Ethereumstorage}, \textit{Receipt Tree} could be used for zero-knowledge proofs or index and searches.
%
\textit{Receipt Tree} contains post-transaction state, cumulative gas used, logs and bloom filter created by the information of logs.
%
Different from the above trees, \textit{State Tree} records a key-value pair for each Ethereum account in an accumulative way.
%
\textit{State Tree} is actually only one global state tree which contains all past account information.
%
Thus, each time a miner generates a new block successfully, she also needs to update this global state correspondingly.
%
Because Ethereum leverages smart contract to achieve reliable computation in an untrusted environment, some extra space is needed to store these contract codes permanently.
%
Ethereum introduces contract accounts to manage these contracts and each contract account has a separate storage trie for that.

\subsection{Data Storage in Lightweight Node}
In practice, many devices with limited computing resources and storage space can't run as a full node.
%
Therefore, in Bitcoin white paper\cite{nakamoto2008bitcoin}, Satoshi Nakamoto puts forward a mechanism called simplified payment verification (SPV) to simplify transaction validation.
%
Through utilizing this mechanism, lightweight client only needs to download all the block headers during the syncing process.
%
Due to the lack of validation resources, lightweight node must query network nodes to download past blocks until she convinces that she has the correct ledger state.

In general, block headers contain enough information to assure that 
\begin{enumerate}
  \item Consensus proof (e.g. nonce) that is used to be against malicious provers.
  \item specific transactions in blocks.
  \item block depth used to convince the validation of transactions.
\end{enumerate}

It is worth nothing that block depth is totally opposite to block height and corresponds to the cumulative difficulty originated from the genesis block.
%
Once SPV client retrieves merkle branch and validates the existence of transaction in a block, she can only rely on the consensus mechanism for the security assurance. 


\section{Research Directions of Stateless Blockchain}
%
Guidelines: In this subsection, you should introduce the typical research directions for encrypted search, describe in detail the goals of each research direction in terms of functionality and/or security. You should also specify and discuss the design challenges in each direction based on your literature study and or your personal perspectives. Besides, you should properly discuss the existing works and try to reflect the state-of-the-art. A possible organization structure is given below. 


\subsection{Basic Searchable Encryption}

\textbf{Goals.} The description goes here.


\textbf{Design challenges.} The description goes here.

\textbf{Related work.} The description goes here.

\subsection{Dynamic Searchable Encryption}

\textbf{Goals.} The description goes here.


\textbf{Design challenges.} The description goes here.

\textbf{Related work.} The description goes here.




\subsection{Boolean Searchable Encryption}

\textbf{Goals.} The description goes here.


\textbf{Design challenges.} The description goes here.

\textbf{Related work.} The description goes here.

\subsection{Any Other Possible Categories}

\textbf{Goals.} The description goes here.


\textbf{Design challenges.} The description goes here.

\textbf{Related work.} The description goes here.

\section{Conclusion}

The conclusion goes here.


\bibliographystyle{IEEEtran}
\bibliography{references}


\end{document}
